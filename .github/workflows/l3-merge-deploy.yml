name: "L3 - Deploy on Merge to Main"

on:
  push:
    branches:
      - main
    paths-ignore:
      - "README.md"
      - ".github/**"

env:
  # Helm chart location inside the repository
  HELM_CHART_DIR: ./helm/app-chart

  # Kubernetes namespace to deploy to
  K8S_NAMESPACE: k8s-cicd-sample

  # Helm release name (can be overridden per repo)
  HELM_RELEASE_NAME: sample-service

  # Local image name that will be built and loaded into kind
  LOCAL_IMAGE_NAME: sample-service
  LOCAL_IMAGE_TAG: sha-${{ github.sha }}

jobs:
  deploy:
    name: "Build image and deploy to ephemeral kind cluster"
    runs-on: ubuntu-latest

    permissions:
      contents: read

    steps:
      - name: "Checkout source code"
        uses: actions/checkout@v4

      - name: "Set up Docker Buildx"
        uses: docker/setup-buildx-action@v3
        # Buildx is recommended for modern Docker builds and caching.

      - name: "Build application image (local only)"
        run: |
          IMAGE="${LOCAL_IMAGE_NAME}:${LOCAL_IMAGE_TAG}"
          echo "Building local image: ${IMAGE}"
          docker build -t "${IMAGE}" -f ./Dockerfile .
          docker images "${IMAGE}"
        env:
          LOCAL_IMAGE_NAME: ${{ env.LOCAL_IMAGE_NAME }}
          LOCAL_IMAGE_TAG: ${{ env.LOCAL_IMAGE_TAG }}
        # This builds the application image locally on the GitHub runner.
        # We do NOT push it to any remote registry in this job.

      - name: "Create kind cluster for CI"
        uses: helm/kind-action@v1
        with:
          cluster_name: ci-cd-demo
          wait: 60s
        # This action installs kind, creates a cluster, and configures kubeconfig.

      - name: "Load local image into kind cluster"
        run: |
          IMAGE="${LOCAL_IMAGE_NAME}:${LOCAL_IMAGE_TAG}"
          echo "Loading image ${IMAGE} into kind cluster 'ci-cd-demo'"
          kind load docker-image "${IMAGE}" --name ci-cd-demo
        env:
          LOCAL_IMAGE_NAME: ${{ env.LOCAL_IMAGE_NAME }}
          LOCAL_IMAGE_TAG: ${{ env.LOCAL_IMAGE_TAG }}
        # `kind load docker-image` makes the locally built image available
        # to all nodes in the kind cluster without using an external registry.

      - name: "Install Helm CLI"
        uses: azure/setup-helm@v4
        with:
          version: v3.16.2

      - name: "Verify cluster connectivity"
        run: |
          echo "Current Kubernetes context:"
          kubectl config current-context
          echo "Listing nodes:"
          kubectl get nodes

      - name: "Create namespace if it does not exist"
        run: |
          kubectl get namespace "${K8S_NAMESPACE}" >/dev/null 2>&1 || \
          kubectl create namespace "${K8S_NAMESPACE}"
        env:
          K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}

      - name: "Helm upgrade --install"
        run: |
          IMAGE="${LOCAL_IMAGE_NAME}"
          TAG="${LOCAL_IMAGE_TAG}"

          echo "Deploying release '${HELM_RELEASE_NAME}' to namespace '${K8S_NAMESPACE}'"
          echo "Using image: ${IMAGE}:${TAG}"

          helm upgrade --install "${HELM_RELEASE_NAME}" "${HELM_CHART_DIR}" \
            --namespace "${K8S_NAMESPACE}" \
            --set fullnameOverride="${HELM_RELEASE_NAME}" \
            --set image.repository="${IMAGE}" \
            --set image.tag="${TAG}"
        env:
          HELM_CHART_DIR: ${{ env.HELM_CHART_DIR }}
          K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}
          HELM_RELEASE_NAME: ${{ env.HELM_RELEASE_NAME }}
          LOCAL_IMAGE_NAME: ${{ env.LOCAL_IMAGE_NAME }}
          LOCAL_IMAGE_TAG: ${{ env.LOCAL_IMAGE_TAG }}
        # The Helm release is configured to use the locally built image,
        # which was already loaded into the kind cluster.

      - name: "Check deployment rollout status (with debug)"
        run: |
          echo "Checking rollout status for ${HELM_RELEASE_NAME}..."
          if ! kubectl rollout status deployment/"${HELM_RELEASE_NAME}" -n "${K8S_NAMESPACE}" --timeout=120s; then
            echo "Deployment did not become ready in time. Debug info:"
            echo "=== Pods in namespace ${K8S_NAMESPACE} ==="
            kubectl get pods -n "${K8S_NAMESPACE}" -o wide || true

            echo "=== Describe deployment ${HELM_RELEASE_NAME} ==="
            kubectl describe deployment "${HELM_RELEASE_NAME}" -n "${K8S_NAMESPACE}" || true

            echo "=== Describe pods ==="
            kubectl describe pods -n "${K8S_NAMESPACE}" || true

            FIRST_POD=$(kubectl get pods -n "${K8S_NAMESPACE}" -l app.kubernetes.io/name="${HELM_RELEASE_NAME}" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ -n "$FIRST_POD" ]; then
              echo "=== Logs from pod ${FIRST_POD} ==="
              kubectl logs "${FIRST_POD}" -n "${K8S_NAMESPACE}" || true
            fi

            exit 1
          fi
        env:
          HELM_RELEASE_NAME: ${{ env.HELM_RELEASE_NAME }}
          K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}
