name: "L3 - Deploy on Merge to Main"

on:
  push:
    branches:
      - main
    paths-ignore:
      - "README.md"
      - ".github/**"

env:
  # Helm chart location inside the repository
  HELM_CHART_DIR: ./helm/app-chart

  # Kubernetes namespace to deploy to
  K8S_NAMESPACE: k8s-cicd-sample

  # Helm release name (can be overridden per repo)
  HELM_RELEASE_NAME: sample-service

  # Docker registry and image details
  REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}
  IMAGE_TAG: sha-${{ github.sha }}

jobs:
  deploy:
    name: "Deploy to ephemeral kind cluster"
    runs-on: ubuntu-latest

    permissions:
      contents: read

    steps:
      - name: "Checkout source code"
        uses: actions/checkout@v4
        # This ensures that the Helm chart and deployment manifests are available.

      - name: "Create kind cluster for CI"
        uses: helm/kind-action@v1
        with:
          cluster_name: ci-cd-demo
          wait: 60s
        # This action:
        #  - installs kind
        #  - creates a Kubernetes cluster inside Docker
        #  - configures kubeconfig for kubectl and Helm.

      - name: "Install Helm CLI"
        uses: azure/setup-helm@v4
        with:
          version: v3.16.2
        # Same Helm version as in L1 for consistent behavior.

      - name: "Verify cluster connectivity"
        run: |
          echo "Current Kubernetes context:"
          kubectl config current-context
          echo "Listing nodes:"
          kubectl get nodes

      - name: "Create namespace if it does not exist"
        run: |
          kubectl get namespace "${K8S_NAMESPACE}" >/dev/null 2>&1 || \
          kubectl create namespace "${K8S_NAMESPACE}"
        env:
          K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}
        # Ensures the target namespace exists before we deploy.

      - name: "Helm upgrade --install"
        run: |
          echo "Deploying release '${HELM_RELEASE_NAME}' to namespace '${K8S_NAMESPACE}'"
          echo "Using image: ${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"

          helm upgrade --install "${HELM_RELEASE_NAME}" "${HELM_CHART_DIR}" \
            --namespace "${K8S_NAMESPACE}" \
            --set fullnameOverride="${HELM_RELEASE_NAME}" \
            --set image.repository="${REGISTRY}/${IMAGE_NAME}" \
            --set image.tag="${IMAGE_TAG}"
        env:
          HELM_CHART_DIR: ${{ env.HELM_CHART_DIR }}
          K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}
          HELM_RELEASE_NAME: ${{ env.HELM_RELEASE_NAME }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        # This command deploys the chart into the kind cluster using the image
        # that was built and pushed by the L2 pipeline.

      - name: "Check deployment rollout status"
        run: |
          kubectl rollout status deployment/"${HELM_RELEASE_NAME}" -n "${K8S_NAMESPACE}" --timeout=120s || {
            echo "Deployment did not become ready in time."
            kubectl get all -n "${K8S_NAMESPACE}"
            exit 1
          }
        env:
          HELM_RELEASE_NAME: ${{ env.HELM_RELEASE_NAME }}
          K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}
        # This step waits until the deployment is ready and prints useful
        # debugging information if something goes wrong.
